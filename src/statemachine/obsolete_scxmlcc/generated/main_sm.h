// This file is automatically generated by obsolete_scxmlcc (version 0.9-)
// For more information, see http://scxmlcc.org
#ifndef __sc_main_state_machine
#define __sc_main_state_machine


class sc_main_state_machine
{
	public:

	struct data_model;
	struct user_model;

	class state
	{
		public:
		virtual ~state(){}
                virtual state* event_trButtonOff(sc_main_state_machine&) { return 0; }
                virtual state* event_trButtonOn(sc_main_state_machine&) { return 0; }
                virtual state* unconditional(sc_main_state_machine&) { return 0; }
                virtual state* initial(sc_main_state_machine&) { return 0; }

		template<class T> void enter(data_model&, ...) {}
		template<class T> void exit(data_model&, ...) {}
		virtual bool in(const void*) { return false; }
	};

        typedef state* (state::*event)(sc_main_state_machine&);

	template<class C> class state_actions
	{
		protected:
		void enter(data_model&) {} // default enter action
		void exit(data_model&) {} // default exit action
	};

	template<class C, class P> class composite : public P, public state_actions<C>
	{
                virtual state* initial(sc_main_state_machine&) { return 0; }
		public:
		typedef P parent_t;
		// LCA calculation
		template<class T> void enter(data_model&, composite*) {}
		template<class T> void enter(data_model &m, ...) { P::template enter<T>(m, static_cast<T*>(nullptr)); state_actions<C>::enter(m); }
		template<class T> void exit(data_model&, composite*) {}
		template<class T> void exit(data_model &m, ...) { state_actions<C>::exit(m); P::template exit<T>(m, static_cast<T*>(nullptr)); }
		static const void* id() { static const struct{} _id; return &_id; }
		bool in(const void *si) { return (si == id() || P::in(si)); }
	};

	class no_state {};
	enum transition_type { external, internal };

	template<event E, class S, class D0 = no_state> class transition_actions
	{
		protected:
		void enter(data_model&) {} // default enter action
		bool condition(data_model&) { return true; } // default condition action
	};

	// external/internal transition
	template<event E, class S, class D = no_state, transition_type T = external> class transition : public transition_actions<E, S, D>
	{
		template<transition_type I> struct id { };
		void state_enter(D* d, data_model &m, id<internal>, S*) { d->template enter<composite<S, typename S::parent_t> >(m); } // internal transition, where dst is descendant of src
		void state_enter(D* d, data_model &m, ...) { d->template enter<typename S::parent_t>(m); } // external transition, or dst is not descendant of src
		void state_exit(S*, data_model &, id<internal>, S*) {} // internal transition, where dst is descendant of src
		void state_exit(S* s, data_model &m, ...) { s->template exit<typename D::parent_t>(m); } // external transition, or dst is not descendant of src
		public:
                state* operator ()(S *s, sc_main_state_machine &sc)
		{
			if(!transition_actions<E, S, D>::condition(sc.model)) return 0;
			D *d = sc.get_state<D>();
			state_exit(s, sc.model, id<T>(), static_cast<typename D::parent_t*>(nullptr));
			transition_actions<E, S, D>::enter(sc.model);
			state_enter(d, sc.model, id<T>(), static_cast<typename D::parent_t*>(nullptr));
			return d;
		}
	};

	private: bool dispatch_event(event e)
	{
		state *next_state;
		if ((next_state = (model.cur_state->*e)(*this))) model.cur_state = next_state;
		return !!next_state;
	}

	public: void dispatch(event e = &state::unconditional)
	{
		bool cont = dispatch_event(e) || dispatch_event(&state::unconditional);
		while (cont) {
			if ((cont = dispatch_event(&state::initial)));
			else if ((cont = dispatch_event(&state::unconditional)));
			else break;
		}
	}
	struct data_model
	{
		state *cur_state;
		template <class S> bool In() { return cur_state->in(S::id()); }
		user_model *user;
		data_model(user_model* um)
		: user(um)
		{}
	} model;

        sc_main_state_machine(user_model *user = nullptr)
	: model(user)
	{
		model.cur_state = get_state<scxml>();
	}

	void init() { dispatch(&state::initial); }

	struct scxml : public composite<scxml, state>
	{
                state* initial(sc_main_state_machine&sc) { return transition<&state::initial, scxml, state_Off, internal>()(this, sc); }
	};

	struct state_Off : public composite<state_Off, scxml>
	{
                state* event_trButtonOn(sc_main_state_machine &sc) { return transition<&state::event_trButtonOn, state_Off, state_On>()(this, sc); }
	};

	struct state_On : public composite<state_On, scxml>
	{
                state* event_trButtonOff(sc_main_state_machine &sc) { return transition<&state::event_trButtonOff, state_On, state_Off>()(this, sc); }
	};

	template<class T> T* get_state()
	{
		static T t;
		return &t;
	}
};

#endif